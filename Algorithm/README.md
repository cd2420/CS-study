# 이분 매칭

`이분 매칭(Bipartite Matching)` 알고리즘은 네트워크 유량 알고리즘과 연계되는 개념으로, 이분 그래프에서 두 그룹간의 최대 매칭을 의미한다.

> 즉, `집단 A`가 `집단 B`를 선택하는 방법에 대한 알고리즘이다.

먼저 `이분 그래프`란, 전체 그래프에서 점 들을 두 그룹으로 나누었을 때, 같은 그룹내에는 간선이 존재하지 않게 나눌 수 있는 그래프를 의미한다.

그래프를 나눌 수 있는 경우가 여러가지기도 하지만, 보통 문제에서는 명확히 두 그룹을 분류해주는 경우가 많다.

### 개념

아래 예시를 통해 이분 매칭의 개념을 대해 알아보도록 하자.

네이버 클라우드, 카카오, 삼성전자에 각각 1자리씩 TO가 났고, 위 세 기업에 입사를 희망하는 3명의 스터디원들이 있다.

<img width="866" alt="스크린샷 2021-10-03 오전 2 59 03" src="https://user-images.githubusercontent.com/51703260/135727444-b9ba4b0a-9d3a-4211-948b-e3c79beceebc.png">

위 예시에서는 `집단 A`가 **스터디원** 들이고, `집단 B`는 **희망 기업** 이라고 할 수 있다. 

이와 같이 각 스터디원들이 희망하는 기업들이 미리 정해져 있을 때, 가장 효과적으로 스터디원들에게 희망 기업을 매칭시켜주는 경우를 이분 매칭으로 알아보자.

먼저, 위 경우를 아래와 같은 그래프로 표현할 수 있다.

<img width="698" alt="스크린샷 2021-10-03 오전 2 59 50" src="https://user-images.githubusercontent.com/51703260/135727445-5e7d280d-5572-4b7c-b51d-f45f5356a7c0.png">

**이분 매칭은, 두개의 그래프를 최대한으로 연결시켜주는 최대 연결(매칭)을 의미한다.**

즉, 최대한 많은 사람이 각각의 희망 기업으로 입사하는 경우를 찾는 문제로 볼 수 있다. 뭔가 느낌이 오지 않는가?

우리가 그전까지 살펴본 `네트워크 유량` 문제 또한 Source에서 Sink로 흘려보낼 수 있는 최대 유량(flow)을 구하는 문제이고,

`이분 매칭` 문제 또한 A에서 B로 갈 수 있는 최다 경우를 구하는 문제이기 때문에, 아래와 같이 **이분 매칭을 네트워크 유량으로 표현할 수 있다.**

<img width="978" alt="스크린샷 2021-10-03 오전 2 59 35" src="https://user-images.githubusercontent.com/51703260/135727447-8d345188-4fc4-42e1-83e8-8cad92173a16.png">

위와 같이 선택을 1가지만 할 수 있는 이분 매칭은 모든 엣지의 용량이 1로 설정된 네트워크 유량 문제로 이해할 수 있다.

우리가 직전에 보았던 에드몬드-카프 알고리즘은 보통 시간 복잡도가 O(V*E^2)라고 알려져 있는데, 이분 매칭의 경우에는 이보다 더 빠르고 효율적으로 알고리즘을 설계할 수 있다.

그게 바로 단순히 **DFS**로 푸는 방법이다. (포드-풀커슨의 DFS가 아닌 그냥 DFS)

<img width="698" alt="스크린샷 2021-10-03 오전 2 59 55" src="https://user-images.githubusercontent.com/51703260/135727449-e6a5ffb5-b5ed-4bae-9551-47341c6d0729.png">

먼저 첫 출발로 문규가 네이버 클라우드를 선택한다. 현재까지는 네이버 클라우드가 아무에게도 선택되지 않았으므로 바로 선택할 수 있다.

<img width="698" alt="스크린샷 2021-10-03 오전 2 59 57" src="https://user-images.githubusercontent.com/51703260/135727452-9ca7f518-c802-4a34-86f4-4e0042b85995.png">

문규의 선택이 끝났다면, 그 다음 경준님이 선택할 차례인데 경준님께서 희망하는 네이버 클라우드는 이미 문규가 선택하고 있는 상황이다.

<img width="698" alt="스크린샷 2021-10-03 오전 2 59 59" src="https://user-images.githubusercontent.com/51703260/135727453-de4ee412-0704-41b1-9956-656e49111f69.png">

이 때, 네이버 클라우드를 선택한 문규가 네이버 클라우드를 제외하고 다른 희망 기업을 선택할 수 있는지 살펴본다. 살펴보니 아직 카카오가 아무에게도 선택되지 않았으므로 카카오를 선택하였다.

그래서 경준님이 네이버 클라우드를, 문규가 카카오를 선택하게 되었다.

<img width="698" alt="스크린샷 2021-10-03 오전 3 00 01" src="https://user-images.githubusercontent.com/51703260/135727454-3ed9986c-9e89-442d-a696-dffe0a07f45d.png">

그 다음 윤주님이 기업을 선택할 차례가 왔다. 윤주님께서 희망하는 카카오는 또 문규가 선택하고 있는 상황이다.

<img width="698" alt="스크린샷 2021-10-03 오전 3 00 03" src="https://user-images.githubusercontent.com/51703260/135727455-e18ebd7f-6934-4847-af89-99bc38bf7135.png">

이 때, 또 카카오를 선택한 문규가 카카오를 제외하고 다른 기업을 선택할 수 없는지 살펴본다. 네이버 클라우드를 혹시나 다시 한번 살펴 봤더니 경준님께서 계속 선택하고 계신 상황이라 선택할 수가 없었다. 

<img width="698" alt="스크린샷 2021-10-03 오전 3 00 05" src="https://user-images.githubusercontent.com/51703260/135727457-2ace68ec-fa73-4eb5-909b-d59d39d80e13.png">

그래서 카카오와 네이버 클라우드를 제외하고 남은 희망 기업중 남아있는 삼성전자를 선택하였다.

<img width="698" alt="스크린샷 2021-10-03 오전 3 00 07" src="https://user-images.githubusercontent.com/51703260/135727458-a596952e-622d-463c-a064-f331657009a8.png">

**이렇게 문규는 삼성전자, 경준님은 네이버 클라우드, 윤주님은 카카오로 매칭되어 입사를 하게 되었다.** 😊

### 시간복잡도

위와 같은 예시처럼 DFS를 이용해 이분 매칭을 간단히 풀 때 시간 복잡도는 `O(V * E)` 이다. 

이 방법은 가장 빠른 속도의 알고리즘은 아니지만 구현이 가장 간단하고 쉽다는 점에서 많이 사용된다.

### 코드
이분매칭의 거의 기본문제라고 할수 있는 [열혈강호 : 백준 11375](https://www.acmicpc.net/problem/11375)문제의 DFS 풀이이다.
```java
import java.io.*;
import java.util.*;

/*
 * 회사에 N명의 직원과, M가지 작업이 있을 때,
 * 해당 회사가 할 수 있는 최대 일의 개수를 구하시오.
 * 
 * 1. 각 직원은 1개의 일을 할 수 있다.
 * 2. 각 작업을 담당하는 사람은 1명이다. 즉, 1 : 1 매칭
 * 3. 각 직원이 할 수 있는 일의 목록이 주어진다.
 * 
 * 직원(집단 A)과 작업(집단 B)을 최대한 매칭시키는 베이직한 이분 매칭 문제.
 * 
 * 메모리 	     시간
 * 78212	964
 */

public class BaekOJ11375_배문규 {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringBuilder sb = new StringBuilder();
	static StringTokenizer st = null;
	
	static final int MAX_SIZE = 1001;
	static int N, M, worker[][], b[];
	static boolean check[];
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		
		worker = new int[N+1][];
		for(int i = 1; i <= N; i++) {
			st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			
			worker[i] = new int[cnt];
			for(int j = 0; j < cnt; j++) worker[i][j] = Integer.parseInt(st.nextToken());
		}
		
		System.out.println(bMatch());
	}
	
	public static int bMatch() {
		b = new int[MAX_SIZE]; // b배열의 인덱스 : 작업 인덱스, b배열의 값 : 직원 인덱스 
		check = new boolean[MAX_SIZE]; // 이미 확인한 직원인지 체크 배열
		int result = 0; // 매칭된 작업 수

		for(int i = 1; i <= N; i++) {
			Arrays.fill(check, false); // 매번 매칭을 시도할 때마다 이미 매칭된 사람도 
									   // 다른 작업으로 매칭이 바뀔 수 있으므로 방문 체크를 초기화 해야함 
			if(dfs(i)) result++; // i번 째 직원이 일과 매칭이 되면 카운트
		}
		
		return result;
	}
	
	public static boolean dfs(int workerIdx) {
		if(check[workerIdx]) return false;  // 이미 확인한 사람은 다시 확인할 필요 없음
		check[workerIdx] = true;
		
		// 해당 직원이 수행할 수 있는 작업들 
		for(int job : worker[workerIdx]) {
			
			// 매칭이 가능한 경우는 2가지가 있다.
			// 1. 아직 해당 작업이 아무런 직원과 매칭이 되어 있지 않았을 때 
			// 2. 이미 해당 작업에 매칭된 직원이 다른 작업도 매칭할 수 있을 때
			if(b[job] == 0 || dfs(b[job])) {
				b[job] = workerIdx; // 직원 <--> 작업 매칭하고 true 리턴
				return true;
			}
		}
		
		return false;
	}
}

```

# 네트워크 유량

![9921CE375BB450461A](https://user-images.githubusercontent.com/51703260/134789412-d2455d13-e1e7-4b73-8b19-cab576011eba.png)

네트워크 유량이란 유방향 그래프에 용량이 존재하는 것이다. 유량의 시작 정점을 Source, 끝 정점을 Sink라고 한다.<br>
이 때, Source에서 Sink로 흘려보낼 수 있는 최대 유량(flow)을 구하는 문제를 네트워크 유량 문제라고 한다.

- `유량(flow)` : 두 정점 사이에서 현재 흐르는 양
- `용량(capacity)` : 두 정점 사이에 최대로 흐를수 있는 양
- `잔여 용량(residual capacity)` : 두 정점 사이에서 현재 더 흐를 수 있는 유량. (용량 - 유량)
- `소스(source)` : 유량이 시작되는 정점. 보통 S로 표현
- `싱크(sink)` : 유량이 도착하는 정점. 보통 T로 표현
- `증가 경로(augmenting path)` : S에서 T로 유량이 흐르는 경로 

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/133916224-1b022950-880b-436a-b105-885ed3c305ed.png"></p>

위 이미지와 같은 네트워크 유량이 있다고 하자.

S에서 1로 갈 수 있는 유량은 2, 2로 갈 수 있는 유량은 3이다.<br>
S에서 1로 2만큼 유량이 흘러갔다면, 1에서 T로 용량은 3이지만 S에서 1로 흘러 들어온 2만큼만 유량을 보낼 수 있다.<br>
마찬가지로, S에서 2로 갈 수있는 유량은 3이라 3을 흘려 보냈더라도 2에서 T로 흐를 수 있는 용량이 2라서 2만큼만 유량을 보낼 수 있다.<br>
결과적으로 위 그래프는 S에서 T로 4를 흘러보내주게 되고, 최대 유량이 4라고 한다.

네트워크 유량 문제가 성립하기 위해서는 3가지 약속이 있다.<br>
일단 네트워크 유량에서는 위에서" S에서 1로 갈 수 있는 유량은 2, 2로 갈 수 있는 유량은 3이다"<br>
라는 표현을 `c(S,1)` = 2, `c(S,2)` = 3 이라고 간단하게 표현할 수 있다.

- `c(u,v)` : `capacity` 정점 u에서 v로 가는 간선의 용량
- `f(u,v)` : `flow` 정점 u에서 v로 실제 흐르는 유량
- `r(u,v)` : `residual` 정점 u에서 v로 가는 잔여 용량 `r(u,v)` =  `c(u,v)` - `f(u,v)`

**1) 용량 제한 속성 `f(u,v)` <= `c(u,v)` :**

두 간선 사이에서 흐르는 유량은 용량을 넘을 수 없다.
 
**2) 유량의 대칭성 `f(u,v)` = `-f(v,u)` :**

u->v로 2만큼 흐른다면, v->u엔 -2만큼 흐른다.
쉽게 생각하면, 'u->v로 2만큼 나가고 v->u로 2만큼 들어온다.' 라고 이해하면 된다.

**3) 유량 보존의 법칙 `∑f(u,v)` = 0 :**
S 와 T를 제외하고는 각 정점에서 들어오는 유량과 나가는 유량이 일치해야 한다.
그래서 유량의 대칭성 때문에 S와 T를 제외하고 유량을 모두 합하면 0이 되어야 한다.

# 포드-풀커슨 알고리즘
최초의 네트워크 유량 알고리즘<br>
개념과 구현이 간단하다.

### 개념
1. 각 간선의 용량을 입력받는다.
2. DFS(포드-풀커슨)를 이용하여 `r(u,v)` > 0인 증가 경로를 찾는다. (DFS 기 때문에 최단경로 아님 )
3. 찾은 증가 경로 상에서 `r(u,v)`이 가장 낮은 엣지를 찾는다.
4. 찾은 엣지의 `r(u,v)`만큼만 S에서 T까지 유량을 흘려보낸다(경로의 모든 엣지에 유량 추가).
5. 더 이상 증가 경로가 발견이 되지 않을 때까지 반복한다.

아래 그래프를 가지고 포드-풀커슨 알고리즘의 과정을 살펴 보면,

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/133918099-b2b92772-fdf9-401b-a51e-dcf4be73666a.png"></p>

S->a->T 라는 증가 경로를 먼저 찾고, 그 다음 S->b->T라는 증가 경로를 찾아서 최대 유량을 찾을 수도 있다.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/133918097-a56dd01d-465e-49d5-9bc4-ee35c1496d38.png"></p>

하지만, 만약 S->a->b->T라는 증가 경로를 가장 먼저 찾았는데, 이때 흘려 보낼수 있는 플로우는 1을 보내고 나니 그 다음 유량을 흘려 보낼 수 있는 루트를 찾아보니 없다.

여기서 위에서 살펴 보았던 **2) 유량의 대칭성** `f(u,v)` = `-f(v,u)`의 개념이 이용된다.<br>
현재 `c(a,b)`는 1이다. 그리고 `c(b,a)`는 경로가 존재하지 않으니 0이다.<br>
그리고 `f(a,b)`도 방금 **S->a->b->T** 라는 증가 경로로 유량이 흘렀기 때문에 1이 되고, 유량의 대칭성에 의해서 `f(b,a)`은 -1이 된다.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/133918095-0f78c106-146f-400a-bb93-5f778eff21c2.png"></p>

그러면 놀랍게도 잔여 용량 `r(b,a)`(`c(b,a)` - `f(b,a)`)은 0 - (-1)로, b에서 a로 흐르는 잔여 용량이 1이 된다.<br>
즉, 유량의 하나 보내는 것은 반대로 유량을 하나 보낼 수 있는 작업이 동반된다고 생각하면 된다.<br>
이렇게 Back-Edge라고 불리는 역간선 덕분에 포드-풀커슨 알고리즘이 성립 가능하게 된다.

그러면 결과적으로는 어떤 경로를 선택하든 최대 유량을 구할 수 있다.

### 시간복잡도
증가경로 한개당 플로우 1밖에 보낼 수 없다.<br>
그래서 DFS를 플로우 수만큼 사용해야 하는데 플로우 수가 크다면 스택오버플로우가 발생할 수 있다.<br>
시간복잡도는 O((V+E)F) 인데, E가 V를 도미넌트 하므로 보통 O(EF)라고 표현한다.

### 코드

[최대 유량 : 백준 6086](https://www.acmicpc.net/problem/6086)문제의 포드-풀커슨 알고리즘 풀이이다.

```java
import java.io.*;
import java.util.*;

/*
 *  메모리		시간
 *  14388	  140
 */
public class BaekOJ6086_배문규_DFS {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringBuilder sb = new StringBuilder();
	static StringTokenizer st = null;
	
	static final int MAX_SIZE = 52;
	static int N, maxFlow, S, T = 25, capacity[][], flow[][];
	static boolean check[];
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		capacity = new int[MAX_SIZE][MAX_SIZE];
		flow = new int[MAX_SIZE][MAX_SIZE];
		check = new boolean[MAX_SIZE];
		
		N = Integer.parseInt(br.readLine());
		for(int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			int start = charToInt(st.nextToken().charAt(0));
			int end = charToInt(st.nextToken().charAt(0));
			int weight = Integer.parseInt(st.nextToken());
			// 여기서는 그냥 연결이기 때문에 무향 그래프라서 양방향으로 웨이트를 둘 다 더해줌
			capacity[start][end] += weight; 
			capacity[end][start] += weight;
		}
		
		// 더 이상 증가경로가 없을 때 까지 반복
		while(true) {
			// 방문 체크 초기화
			Arrays.fill(check, false);
			// DFS로 최대 유량 찾기
			int flowAmount = dfs(S, Integer.MAX_VALUE);
			if(flowAmount == 0) break;
			maxFlow += flowAmount;
		}
		
		System.out.println(maxFlow);
	}
	
	public static int dfs(int from, int amount) {
		// 증가경로가 완성되면 해당 증가경로의 최소 잔여용량 리턴
		if(from == T) return amount;

		// 방문한 곳이면 리턴
		if(check[from]) return 0;
		check[from] = true;
		
		for(int to = 0; to < MAX_SIZE; to++) {
			// 유량이 흐를 수 있으면
			if(capacity[from][to] > flow[from][to]) {
				// 현재 도달한 경로까지의 최소 잔여용량 저장
				int flowAmount = dfs(to, Math.min(amount, capacity[from][to]-flow[from][to]));
				if(flowAmount > 0) {
					// 잔여용량 갱신하고 리턴
					flow[from][to] += flowAmount;
					flow[to][from] -= flowAmount;
					return flowAmount;
				}
			}
		}
		
		return 0;
	}
	
	// 문자를 인덱스로 매핑하기 위해 변환
	public static int charToInt(char c) {
		if('a' <= c && c <= 'z') c -= 6;
		return c - 65;
	}
}
```

# 에드몬드-카프 알고리즘

앞서 살펴본 `포드-풀커슨` 알고리즘은 임의의 유량 그래프가 주어졌을 때, 원래 경로가 이미 사용되어 막혀있어도 `Back-Edge` 덕분에 최대 유량은 확실하게 구할 수 있다는 것을 알게되었다.

하지만 최대 유량만 알 수 있지, 우리가 생각하는 유량이 흐르는 실제 경로를 제시하지는 않는다.

아래 유량 그래프를 다시 한 번 예시로 보자.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/133916224-1b022950-880b-436a-b105-885ed3c305ed.png"></p>

`포드-풀커슨` 알고리즘에서는 S->1->2->T 가 먼저 증가경로로 잡히면, 유량의 대칭성으로 잔여 유량이 1이 생겨 2->1로 갈 수 있는 경로가 생겨서 S->2->1->T라는 증가경로가 생기게 되어서 

- S->1->2->T (유량 1 보냄)
- S->2->1->T (유량 1 보냄)
- S->1->2->T (유량 1 보냄)
- S->2->1->T (유량 1 보냄)
- **최대 유량 : 4**

이런 방식으로 결국 최대 유량을 알게되었다. 그래서 총 4번의 증가경로 탐색이 필요하다.

이렇기 때문에 위 그래프와 같이 중간에 용량이 1인 엣지가 끼어있는 병목상태에서는 `포드-풀커슨` 알고리즘은 굉장히 비효율적으로 동작할 수 있다.

하지만 실제 유량이 흐르는 증가경로는 아래와 같다.

- S->1->T (유량 2 보냄)
- S->2->T (유량 2 보냄)
- **최대 유량 : 4**

위 방식처럼 동작하는 알고리즘이 바로 `에드먼드-카프` 알고리즘이다.

`포드-풀커슨` 알고리즘이 DFS 방식으로 증가경로를 탐색했다면, `에드먼드-카프` 알고리즘은 BFS 방식으로 증가경로를 탐색한다. 

가장 짧은 경로의 증가 경로를 탐색하여 해당 증가경로로 보낼 수 있는 최대의 유량을 한번에 보내면 된다.

즉, 최단거리로 최대의 유량을 보내기 때문에 중간에 용량이 1인 엣지가 끼어있어도 돌아가는 길이라면 무시할 수 있는 것이다.

잔여용량이 남은 간선들만을 이용해서 BFS를 반복적으로 수행하고, 찾은 경로들에게 유량을 보내고, 더이상 할 수 없을때까지 보낸 총 유량을 반환하기만 하면 된다.

### 개념
1. 각 간선의 용량을 입력받는다.
2. BFS(에드몬드-카프)를 이용하여 `r(u,v)` > 0인 증가 경로 중 최단 거리를 찾는다.
3. 찾은 증가 경로 중에서 `r(u,v)`이 가장 낮은 엣지를 찾는다.
4. 찾은 엣지의 `r(u,v)`만큼만 S에서 T까지 유량을 흘려보낸다(경로의 모든 엣지에 유량 추가).
5. 더 이상 증가 경로가 발견이 되지 않을 때까지 반복한다.

### 시간복잡도
BFS 한번이 O(E)이고, 증가 경로를 최대 VE번 찾기 때문에 `에드먼드-카프` 알고리즘의 일반적으로 알려진 시간복잡도는 O(VE^2)라고 한다.

증가 경로를 최대 VE번 찾는 이유(복잡함)에 대한 더 이상의 자세한 설명은 생략한다.

정확하게는 min(O(|E|f), O(VE^2))라고 하는데 만약 간선은 많고, 흘러야 하는 유량이 적을 때는 O(|E|f) < O(VE^2)이 될 수 있다고 한다.

#### 코드

[최대 유량 : 백준 6086](https://www.acmicpc.net/problem/6086)문제의 에드몬드-카프 알고리즘 풀이이다.

```java
import java.io.*;
import java.util.*;

/*
 *  메모리 	시간
 *  14208	136
 */

public class BaekOJ6086_배문규_BFS {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringBuilder sb = new StringBuilder();
	static StringTokenizer st = null;
	
	static final int MAX_SIZE = 52;
	static int N, maxFlow, S, T = 25, aPath[], capacity[][], flow[][];
	static Queue<Integer> queue;

	public static void main(String[] args) throws NumberFormatException, IOException {
		capacity = new int[MAX_SIZE][MAX_SIZE];
		flow = new int[MAX_SIZE][MAX_SIZE];
		
		N = Integer.parseInt(br.readLine());
		for(int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			int start = charToInt(st.nextToken().charAt(0));
			int end = charToInt(st.nextToken().charAt(0));
			int weight = Integer.parseInt(st.nextToken());
			// 여기서는 그냥 연결이기 때문에 무향 그래프라서 양방향으로 웨이트를 둘 다 더해줌
			capacity[start][end] += weight; 
			capacity[end][start] += weight;
		}
		
		queue = new ArrayDeque<Integer>();
		aPath = new int[MAX_SIZE];
		// 더 이상 증가경로가 없을 때 까지 반복
		while(true) {
			// 큐, 증가경로 초기화
			queue.clear();
			Arrays.fill(aPath, -1);
			aPath[S] = S;
			queue.add(S);
			
			// BFS로 최단거리 증가경로 찾기
			while(!queue.isEmpty() && aPath[T] == -1) {
				int from = queue.poll();
				for(int to = 0; to < MAX_SIZE; to++) {
					// 유량이 흐를 수 있으면서, 아직 방문하지 않았다면
					if(capacity[from][to] > flow[from][to] && aPath[to] == -1) {
						queue.offer(to);
						aPath[to] = from;
					}
				}
			}
			
			// 경로가 없으면 종료
			if(aPath[T] == -1) break;
			
			// 찾은 증가 경로의 r(u,v)의 최솟값 (최소 잔여 용량)을 찾음 
			int flowAmount = Integer.MAX_VALUE;
			for(int i = T; i != S; i = aPath[i]) 
				flowAmount = Math.min(capacity[aPath[i]][i] - flow[aPath[i]][i], flowAmount);

			for(int i = T; i != S; i = aPath[i]) {
				flow[aPath[i]][i] += flowAmount; // 경로들에 유량 흘러줌
				flow[i][aPath[i]] -= flowAmount; // 유량의 대칭성으로 반대 경로에 - 유량 흘림
			}
			
			maxFlow += flowAmount;
		}
		
		System.out.println(maxFlow);
	}
	
	// 문자를 인덱스로 매핑하기 위해 변환
	public static int charToInt(char c) {
		if('a' <= c && c <= 'z') c -= 6;
		return c - 65;
	}
}

```

# 알고리즘
1. 알고리즘 분석
	1. 시간 복잡도와 공간복잡도
	2. 알고리즘의 정당성 증명
2. [알고리즘 설계 패러다임](#알고리즘-설계-패러다임)
	1. 완전 탐색
	2. 분할 정복
	3. 동적 계획법
	4. 탐욕법
	5. 조합 탐색
	6. [파라메트릭 서치](#파라메트릭-서치)
3. [유명한 알고리즘](#유명한-알고리즘)
	1. 수치해석
	2. [정수론](#정수론)
		1. [소수](#소수)
		2. [유클리드 알고리즘](#유클리드-알고리즘)
		3. [모듈라 연산](#모듈라-연산)
		4. [이항 계수](#이항-계수)
	3. 계산 기하
4. 기초 자료구조
	1. 비트마스크
	2. 부분 합
	3. 선형 자료 구조
	4. 큐와 스택, 데크
	5. 문자열
5. 트리
	1. 트리의 구현과 순회
	2. 이진 검색트리
	3. 우선순위 큐와 힙
	4. 구간 트리
	5. 상호 배타적 집합
	6. 트라이
6. [그래프](#그래프)
   1. [그래프의 표현과 정의](#그래프의-표현과-정의)
   2. [DFS](#DFS)
   3. BFS
   4. 최단 경로 알고리즘
      1. 다익스트라
      2. 벨만-포드
      3. 플로이드의 모든 쌍 최단 거리 알고리즘
   5. 최소 스패닝 트리
      1. 크루스칼의 최소 스패닝 트리 알고리즘
      2. 프림의 최소 스패닝 트리 알고리즘
   6. 네트워크 유량
      1. 포드-풀커슨 알고리즘
      2. 네트워크 모델링
      3. 이분 매칭
7. 정렬

# 알고리즘 설계 패러다임
# 파라메트릭 서치
결정 문제란 예 아니오 형태의 답만이 나오는 문제들을 가리킨다.

어떤 문제에서 최대가 되는 k를 구하려는 최적화 문제를 결정 문제로 바꾸는 것은 다음과 같다.

__1. k가 x이상일때 문제가 해결되는지?__

__2. 문제 해결이 안된다면 y값을 조절시켜 변경된 x이상일 때는 문제가 해결되는지?__

__3. x값 조절은 이분법을 사용__

위 과정을 반복하면 x는 문제가 해결되는 최적의 값으로 수렴하게 된다.

이렇게 결국 원래 문제인 최대값 k를 구할 수 있다. 같은 매커니즘으로 최솟값도 찾을 수 있는데, 이러한 알고리즘을 일명 파라메트릭 서치라고 부른다.

x값 조절을 이분법으로 하기 때문에, 바이너리 서치와 매우 유사하다.

하지만 차이점이 있는데, 바이너리 서치는 찾고자하는 특정한 값과 정렬된 검색 공간의 가운데에 있는 원소를 비교하여 해당 값을 찾으면 리턴, 못 찾으면 -1을 리턴해준다.

파라메트릭 서치는 특정한 값을 찾는것이 아니라 검색 공간의 가운데 값이 해당 값이 문제를 해결할 수 있는지 판단하고 범위를 좁히는데, 파라메트릭 서치는 바이너리 서치와 다르게 특정한 목표값이 없기 때문에 중간에 리턴을 할 수가 없고 반드시 값이 수렴하기 때문에 -1을 리턴하지 않는다는 차이가 있다. 

아래 문제는 파라메트릭 서치로 해결할 수 있는 가장 간단한 문제들 중 하나이다.

> __n개의 줄을 잘라서 길이(k)가 모두 동일한 m개의 줄로 만들 때, 잘라진 줄의 길이 k의 최대값을 구하라.__
> 
> __항상 n ≦ m 이며, n는 1이상 10,000이하의 정수이고, m은 1이상 1,000,000이하의 정수이다.__
> 
> __그리고 주어진 n개의 줄의 최대 길이는 2^31 - 1보다 작거나 같은 자연수이다.__
>
> __테스트 케이스로 n = 4, m = 11__
>
> __n개의 줄의 길이는 각각 802, 743, 457, 539가 주어졌다.__

최대의 k을 찾는 위 최적화 문제를 k가 x라면 줄을 m개 만들 수 있나? 라는 결정문제로 바꾸어서 풀 수 있다.

__1. k가 x라면 줄을 m개 만들 수 있나?__

__2. m개를 만들 수 없을때, x값을 줄임.__

__3. m개를 만들 수 있을때, x값을 늘림.__

__4. y+1이 m개를 만들 수 없으면 y가 k가 됨__

파라메트릭 서치 문제를 풀 때 초기 정의역x를 반드시 유효한 답을 도출할 수 있도록 잡아야 한다.

parametric_search(int min, int max) 에서  일반적으로 min은 0으로 잡으면 되고 max값을 넉넉히 잡으면 좋다.

위 문제 같은 경우는 만약 n = 4, m = 4이고, n개의 줄이 800, 1, 1, 1같은 테스트 케이스를 고려하면,

k = 200이 되므로 일반적으로 max범위는 n의 줄 길이 중 최대 길이인 800로 잡으면 된다.

```
// 수도코드
parametric_search(min, max){
	if(min > max) return max; // 기저조건, 값이 수렴

	x = (min + max)/2; // 범위 조절, 판단을 위한 x값을 정의
	
	// 있다 -> x값을 늘림 (최적값 수렴)
	// 없다 -> x값을 줄임
	if(isPossible(x)) return parametric_search(x+1, max);
	else return parametric_search(min, x-1);
}

isPossible(x){
	// 일반적으로 결정 판단을 위한 값을 구할때, 이 문제보다 훨씬 난이도가 높고 복잡하다.
	count = 0; // 결정 판단을 위한 값
	for(rope_length : rope_list) 
		count += rope_length / x; // x로 몇개의 줄을 만들 수 있는지
	
	// m개를 만들 수 있다, 없다
	if(count >= m) retrun true;
	else return false;
}
```

재귀의 기저조건인 if(min > max) return max;는 문제마다 차이가 있다.

어떤 문제는 if(min > max) return min; 일수도 있기 때문에 무조건 위 조건을 따라선 안되고 해당 문제를 이해하고 알맞은 조건을 기저조건으로 설정하여야 한다.

그리고 일반적으로 min은 left 또는 start, max는 right 또는 edn, x는 pivot 또는 mid 라는 변수명을 사용한다. 

지금 까지 본 문제는 파라메트릭 서치의 개념을 설명하기 위한 기초적인 문제였다면, 아래문제는 파라메트릭 서치의 응용 문제라고 할 수 있다. 

응용 문제같은 경우는 애초에 파라메트릭 서치 알고리즘을 이용해서 문제를 풀어야겠다는 아이디어 자체를 떠올리기가 쉽지않다...

[백준 1300번 : K번째 수](https://www.acmicpc.net/problem/1300)

[백준 12015번 : 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)

# 유명한 알고리즘

# 정수론
정수론(Number Theory)은 각종 수의 성질을 대상으로 하며 기하학, 대수학, 해석학과 함께 수학의 주요한 분야들 중 하나이다. 

정수론의 현실 세계에서의 쓰임새는 다른 수학 분야에 비해 적지만, 컴퓨터가 발달되면서 사용빈도가 늘었다. 암호학의 기본 이론도 이 정수론을 기본으로 하고 있으며, 정보와 관련된 이론들도 상당 부분 정수론을 기본으로 한다. 

그 이유는 컴퓨터에서 정수는 정확한 값을 가질 수 있기 때문이다. 실수형 타입의 경우에는 round off error 때문에 오차가 생기고, 이 오차는 계산을 거듭할수록 걷잡을 수 없이 커지기 때문이다.
게다가 컴퓨터에서의 수 표현은 수를 표현할 저장공간의 한계상 정수론에서 말하는 시계 산술을 사용한다.

이름은 '정수론'이지만 기초 수준에서는 정수보다는 자연수, 그중에서도 소수를 중점적으로 다룬다. 자연수는 1과 소수, 그리고 합성수로 이루어져 있는데, 합성수들은 소수의 곱으로 생각할 수 있기 때문에 결국 소수가 다른 정수들보다 더 중요한 대우를 받게 된다.

음의 정수는 잘 다뤄지지 않는데, 대부분의 곱셈에 관련된 문제에서 양의 정수에 -1을 곱하는 것으로 음의 정수를 다룰 수 있기 때문이다. 

## 소수
소수를 한마디로 설명하면, 1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수라고 할 수 있다.

애초에 전제조건이 1보다 큰 자연수 중이기 때문에, 당연히 1은 소수가 아니다.

산술의 기본 정리(모든 양의 정수는 유일한 소인수 분해를 갖는다.)의 '1보다 큰 모든 자연수는 그 자체가 소수이거나, 순서를 무시하고 유일한 소인수의 조합을 갖는다'는 내용을 바탕으로 자연수는 1과 소수, 그리고 합성수로 구분된다. 

이 합성수들은 소수의 곱으로 생각할 수 있기 때문에 결국 2이상의 모든 수들은 소수들로 구성되어 있다고 볼 수 있다.

Problem Solving을 하다 보면, 소수와 관련된 문제들을 자주 접할 수 있다. 소수는 경우에 따라 변하지 않으므로 N 이하의 소수는 이미 정해져 있기 때문에, 이 이미 정해진 대량의 소수들을 빠르게 구할 수 있는 방법들이 존재한다.

그 중 대표적인 방법으로 에라토스테네스의 체가 있다. 여기서 체는 대수학에서 사용하는 유리수의 집합, 실수의 집합, 복소수의 집합을 유리수체(體), 실수체(體), 복소수체(體)라고 부르는 Field가 아닌 가루나 액체를 거를 때 사용되는 도구를 뜻한다. 

지구의 크기를 처음으로 계산해 낸 수학자로도 유명한 고대 그리스의 수학자 에라토스테네스가 만들어 낸 특정 범위 내의 소수를 구하는 방법으로, 소수가 아닌 수를 거르는 방법이 마치 체로 치듯이 수를 걸러낸다고 하여 '에라토스테네스의 체'라고 부른다고 한다. 

에라토스테네스의 체로 소수를 찾는 방법은 아래와 같다.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/131170962-794ff277-21b4-458b-bddf-86522bd05895.gif"></p>

만약 100만 이하의 소수들을 모두 구한다고 하자.

1. 2를 제외한 2의 배수들은 모두 제거한다.
2. 3을 제외한 3의 배수들은 모두 제거한다.
3. 제거 되지 않은 가장 작은 수를 제외한 해당 수의 배수를 제거한다.
4. 100만의 제곱근인 1000까지만 체크하여 해당 수들의 배수들을 모두 제거한다.

위 과정이 끝나고 제거되지 않은 수들이 100만 이하의 소수가 된다.

여기서 중요한 점은 에라토스테네스의 체를 이용해 N 이하의 소수를 구하고 싶다면, N까지 배수들을 찾아 볼 필요는 없이 N의 제곱근까지만 체크하면 된다. 

만약 N보다 작은 합성수 M이 있을 때, M = A * B 라면 A와 B 중 적어도 하나는 N의 제곱근 보다 작다. 즉, M은 N의 제곱근 이하에서 이미 배수체크가 가능해지고 소수가 걸러진다.

같은 논리로 결국 N 또한 N의 제곱근이하에서 이미 배수체크가 완료되어 소수가 다 걸러지게 된다.

```
// 수도코드
eratosthenes(N){
	isPrime = boolean[N+1]; // 0 ~ N 까지 논리형 배열
	isPrime.fill(true); // 전부 true로 초기화 (그냥 이렇게 초기화가 가능하다고 가정)
	isPrime[0] = isPrime[1] = false; // 0과 1은 소수가 아님
	
	for(i = 2; i <= sqrt(N); i++){ // N의 제곱근 까지만 체크
		if(!isPrime[i]) continue; // 소수가 아니면 continue
		for(j = i*i; j <= N; j += i){
			isPrime[j] = false; // i의 제곱부터 시작해서 i의 배수는 모두 소수가 아님.
		}			    // i * 2부터 시작해도 되지만 어차피 i가 sqrt(N)까지 접근하기 때문에 동일함
	}
	
	return isPrime;
}

main(){
	N = 1000000;
	isPrime = eratosthenes(N);
	for(i = 0; i <= N; i++){
		if(isPrime[i]) print(i);
	}
}
```
다만 에라토스테네스의 체는 '특정 범위 내의 소수'를 구하는 데에만 효율적이다.

만약 주어진 수 하나가 소수인가? 만을 따지는 상황이라면 에라토스테네스의 체 보다 비교도 안되게 빠른방법이 넘쳐난다.

아래 문제는 에라토스테네스의 체를 이용해서 해결할 수 있는 기본적인 소수를 구하는 문제와 약간 응용한 문제들이다.

[백준 1929번 : 소수 구하기](https://www.acmicpc.net/problem/1929)

[백준 4948번 : 베르트랑 공준](https://www.acmicpc.net/problem/4948)

[백준 9020번 : 골드바흐의 추측](https://www.acmicpc.net/problem/9020)


## 유클리드 알고리즘

유클리드 알고리즘은 우리에게 유클리드 호제법이라고 더 알려져있다.

수학자 유클리드에 의해 기원전 300년경에 발견된 이 알고리즘은 주어진 두 수 사이에 존재하는 최대공약수를 구하는 알고리즘이다.

이 알고리즘의 원리는 아래와 같다.

만약 임의의 두 자연수 A와 B의 최대공약수를 구한다고 하자.

1. A를 B로 나눈 나머지 M을 구한다. M = A % B
2. 이 때 A가 B보다 작으면 M은 A가 된다. (굳이 A와 B의 대소 반별이 필요없다는 의미)
3. 만약 A가 B보다 커서 M == 0 가 된다면 B가 최대 공약수가 된다.
4. 만약 M이 0이 아니면, A에 B값을 넣고, B에 M값을 넣어서 다시 1.의 M = A % B 연산을 하여 M이 0이 될 때 까지 반복한다.

```
// 수도코드
// 재귀
euclid(A, B){	
 	return B == 0 ? A : euclid(B, A % B);
}

// 반복문
euclid(A, B){ 
	while(B != 0){
		A = B;
		B = A % B;
	}
	return A;
}
```

A와 B의 최대공약수를 구했으면, A와 B의 최소공배수는 A * B / (A와B의 최대공약수)로 구할 수 있다

아래 문제는 유클리드 호제법을 이용해서 해결할 수 있는 기본적인 문제이다.

[백준 1934번 : 최소공배수](https://www.acmicpc.net/problem/1934)

## 모듈라 연산

몇 가지 중요한 암호 시스템은 계산 결과가 항상 0 - (M-1) 범위에있는 경우 모듈라 연산을 사용한다고 한다.

이때 M이 우리가 %를 하고자 하는 모듈라 값이다.

아래는 modular를 mod를 표현한 우리가 기본적으로 알고있는 모듈라 연산이다

43 mod 6 = 1

27 mod 9 = 0

3 mod 20 = 3

50 mod 17 = 16

그리고 음수의 경우에도 모듈러 연산이 가능하다.

-13 mod 11 = 9

-10 mod 11 = 1

일반적으로 수학적으로 나머지는 양수라고 약속했기 때문에 음수를 mod 할 경우에는 양수라 생각하고 mod를 한 값의 음수에서 + m을 해주면 된다.

예를 들어 -13 mod 11이면 13 mod 11 = 2 에서 -2 + 11 = 9와 같다.

하지만 프로그래밍을 할 때 A % B 에서 A 또는 B가 음수가 되면 결과는 어떻게 될까?

놀랍게도 답은 ["구현마다 다르다(Implementation-defined)"](https://en.wikipedia.org/wiki/Modulo_operation#In_programming_languages
)

당장 파이썬에서 -10 % 4는 2가 출력되고 10 % -4는 -2가 출력된다.

그리고 C++17 -10 % 4는 -2가 출력된다. 그렇기 때문에 음수 모듈라 연산을 할 때는 언어별로 다르다는 점을 미리 고려해야 할 것 같다.

## 모듈라 합동

모듈라 연산에 이해했다면 모듈라 합동에 대해서도 알면 좋을것 같다.

__(A mod M) = (B mod M) => A ≡ B (mod M)__

어떤 값 A와 B가 M으로 나누었을 때 나머지가 같다면 A와 B는 모듈라 M에 대한 합동 관계라고 표현한다.

여기서 A와 B는 A - B를 하였을 때, M의 배수가 된다.

다시 말해 A - B = K * M (K는 임의의 정수)이다.

예를 들어 13 % 6 = 1이고, 25 % 6 = 1이므로, 13과25는 모듈라 6에 대한 합동이라고 말할 수 있다.

아래 문제는 이 모듈라 합동에 관련된 문제이다.

[백준 2981번 : 검문](https://www.acmicpc.net/problem/2981)

## 모듈라 연산의 속성

모듈라 연산에는 재밌는 속성들이 존재한다.

먼저 (A + B) mod M = ((A mod M) + (B mod M)) mod M  이 성립한다.

그리고 (A - B) mod M = ((A mod M) - (B mod M)) mod M 이 성립하며

놀랍게도 (A * B) mod M = ((A mod M) * (B mod M)) mod M 또한 성립한다.

우리는 수학자가 아니라 공학자이므로 증명은 생략하고 위 공식을 잘 써먹기만 하면 된다.

이 공식을 잘 이용한다면 아래와 같은 문제를 풀 수 있다.

> 2^50이상은 계산할 수 없는 계산기가 존재한다.
> 
> 이 계산기는 mod 연산을 할 수 있는 기능이 탑재되어있다.
> 
> 이 때 2^90 mod 13을 구하라.

이 문제는 거듭제곱을 가지는 값을 모듈라 곱셈 속성을 이용해서 분할 정복으로 해결할 수 있다.

2^90은 2^50 * 2^40이다. 그러면 2^90 mod 13은 

(A * B) mod M = ((A mod M) * (B mod M)) mod M 를 이용하여

2^90 mod 13 = (2^50 * 2^40) mod 13 = ((2^50 mod 13) * (2^40 mod 13)) mod 13으로 변형시킬 수 있다.

계산기를 통해서 2^50 mod 13 = 4, 2^40 mod 13 = 3이라는 값은 바로 구할 수 있다고 했을 때,

결국 2^90 mod 13 = 12 mod 13 = 12라는 사실을 알 수 있다.

## 이항 계수

우선 이항 계수를 다루기전에 근본적으로 이항 정리에 대해 알아야 한다.

![화면 캡처 2021-09-01 230923](https://user-images.githubusercontent.com/51703260/131686399-5fe4ea2c-cc02-431a-80f1-a243b6ebcf13.png)

이항 정리는 (A + B)^n (여기서 n은 음이 아닌 정수)라는 다항식을 전개할 때 쓰는 정리이며, 여기서 '이항'이라는 단어는 '두 개의 항'이라는 뜻이다. 

이항 계수는 (A + B)^n 라는 다항식을 전개했을 때, A^r*B^(n-r) (0 <= r <= n인 정수)의 계수를 의미한다.

A^r*B^(n-r)의 계수는 총  n개의 문자를 배열하는 경우의 수와 같으며, 이는 조합과 같다.
			    
그래서 A^r*B^(n-r)의 계수는 nCr과 같다.

우리는 이항 계수의 수학적인 증명이나 성질을 자세하게 다루기보다는 PS에 이항 계수 관련 문제가 나오면

어떻게 이 이항 계수를 빠르고 효율적으로 구할 수 있느냐를 중점적으로 알아보려고 한다.

2가지 문제를 통해서 이항 계수 PS을 알아보도록 하자. 먼저 가장 기초적인 이항 계수를 구하는 문제이다.

> 자연수 N과 정수 K가 주어졌을 때, 이항 계수를 10,007으로 모듈라 연산한 값을 구하시오. (1 <= N <= 1,000 / 0 <= K <= N)

```
binomial_coefficient(N, K){
	K = Max(K, N-K); // K와 N-K 중 큰 수를 고른다. return으로  K를 나눈 값을 return하는데 K가 0일 수 있기 때문에
	A = N;
	
	for(i = K-1; i > 0; i--){
		A = A * (N - i); // nPk
		K = K * i;	// k!
	}
	
	return A/K; //nPk/k! == nCk
}
```
보통 위 같은 문제는 겉으로 보기에는 return 값이 엄청나게 커져 오버플로우가 발생할 수 있기 때문에 보기 편하게 10,007을 나눈 나머지 값을 구하라는 문제라고 생각할 수 있다.

그리고 실제로 N의 범위가 1,000까지기 때문에 정석적인 방식으로 이항계수를 구하고 모듈라 연산을 그냥 리턴할 때 하면 된다.

만약 N의 범위가 4,000,000이라면 위처럼 구할 수 있을까? 동일하게 자연수 N과 정수 K가 주어졌을 때, 이항 계수를 구하는 문제인데,

N의 범위를 4,000,000까지 확장하여 이항 계수를 1,000,000,007으로 모듈라 연산한 값을 구하여라.

이 땐 처음 문제와 다르게 모듈라 연산의 존재 유무가 중요해졌다.

이 문제를 풀기 위해서는 우리가 앞서 배운 모듈라 연산의 분배법칙 속성을 활용해야 한다.

N과 K의 이항계수는 nCk = N!/(K!*(N-K)!) 로 구할 수 있다.

그렇다면 이 이항계수를 모듈라 연산으로 분할정복해서 구할 순 없을까?

하지만 위에서 봤을 때, 덧셈, 뺄셈, 곱셈에 대해서는 분배법칙이 존재했지만, 나눗셈은 존재하지 않았다.

즉, (A / B) mod M != ((A mod M) / (B mod M)) mod M 이라는 것이다.

여기서 A를 N!, B를 K!*(N-K)! 이라고 대입해보자.

(N! / K!*(N-K)!) mod M != ((N! mod M) / (K!*(N-K)! mod M)) mod M 으로 바꿀 수 있다.

왜 성립하지도 않는데 귀찮게 대입을 해서 식을 직접 눈으로 확인해 본 이유가 있다.

우리가 이항 계수의 분수가 나눗셈이기 때문에 분배법칙이 적용되지 않았는데, 이 분수를 비틀어서 곱셈으로 만들어 버린다면 이항계수의 분배법칙을 가능하게 할 수 있다.

그렇다면 곱셈꼴로는 어떻게 만들까? 분수를 곱셈꼴로 만드는 방법은 역원을 이용하면 쉽게 만들 수 있다.

만약 A / B = C 라면, 이는 A * B^(-1) = C라는 의미이다. 즉 A 나누기 B는 A 곱하기 B의 역원과 같다.

그렇기 때문에, (N! / K!*(N-K)!) mod M는 (N! * (K!*(N-K)!)^(-1)) mod M 로 표현 가능하다.

역원을 이용해 나눗셈을 곱셈까지는 표현하는데는 성공하였다. 그런데 나눗셈이 존재했던 이유는 분수때문이고, 분수의 역원은 어쨌든 분수가 아닌가? 

이 문제를 해결하기 위해서 필요한 공식이 '페르마의 소정리'이다.

페르마의 소정리는 다음과 같다.

> A는 정수, P는 소수이며 A가 P로 나눠지지 않을 때, (A는 P의 배수가 아니라는 뜻)
>
> A^P ≡ A (mod P)이다. (P에 대해 모듈라 합동이다 : P를 나눈 나머지가 같다.)
 
이는 이렇게 표현이 가능하다 -> A^P mod M ≡ A mod M
 
다시 말하지만 우리는 위 공식이 어떻게 증명되는지에 대해서는 관심없고 증명된 공식들을 잘 써먹는데에 관심이 있는 공학자들이다.

위 표현식을 다시 응용하면, A^(P-1) ≡ 1 (mod P) => A * A^(P-2) ≡ 1 (mod P)로 변형이 가능하다.

놀랍게도, A (mod P)에 대한 역원은 A^(P-2) (mod P)라는 것이다.

그렇다면 다시 문제로 돌아와서 해당 분수의 역원을 페르마의 소정리로 구해보면,

A는 (K! * (N-K)!) , P는 1,000,000,007 로 대입할 수 있다.

A^(-1) = A^(P-2) = (K! * (N-K)!)^(-1) = (K! * (N-K)!)^1,000,000,005 가 된다.

이제는 더 이상 역원이 분수가 아닌 정수로 표현되니, 모듈라 곱셈 분배 법칙 적용할 수 있게 되었다.

최종적으로 도출되는 식은 아래와 같다.

  N! / (K!*(N-K)!) mod M
= (N! * (K!*(N-K)!)^(-1)) mod M 
= (N! * (K!*(N-K)!)^(M-2)) mod M 
= ((N! mod M) * (K! * (N-K)!)^(M-2) mod M) mod M

이렇게 정리가 된다.

이제 곱셈 분배법칙이 적용되니 분할 정복을 하여야 한다.

분할 정복은 (K! * (N-K)!)^(M-2)에서 지수 M-2를 계속 절반씩 나눠서 지수가 짝수일 때와 홀수일 때를 구분하여 리턴해주면 된다.

아래는 위 문제의 수도코드이다.
```
// 수도코드
M = 1,000,000,007
A = factorial(N); // N!
B = factorial(K) * factorial(N-K) % M; // K!*(N-K)!

print(A * pow(B, M-2) % M); // (N! * (K!*(N-K)!)^(M-2)) mod M  

// 팩토리얼 구하면서 mod M을 계속 해줌
factorial(num){
	result = 1;
	while(num > 1){
		result = (result * num--) % M
	}
	
	return result;
}

// num : 밑수, exp : 지수
divide_conquer(num, exp){
    	if(exp == 1) return num % M; // 지수가 1일 경우 num^1 이므로 num % M 리턴
    	
	temp = divide_conquer(num, exp/2); // 모듈라 연산 곱셈 분배법칙을 이용한 분할 정복
	
	if(exp % 2 == 1) return (temp * temp) * num % M; // 분할 정복이 끝나고 지수가 홀수가 남으면 ex)A^5 = A^2 * A^2 * A
	else return temp * temp % M; // 지수가 짝수면 A^4 = A^2 * A^2
}
```

---

# 그래프
# 그래프의 표현과 정의
어떤 자료나 개념을 표현하는 정점(vertex)들의 집합 V와 이들을 연결하는 간선(edge)들의 집합 E로 구성된 자료구조

주로 현실 세계의 사물이나 추상적인 개념 간의 연결관계를 표현할 때 사용

## 그래프 관련 용어

- 노드 (Node): 위치를 말함, 정점(Vertex)라고도 함

- 간선 (Edge): 위치 간의 관계를 표시한 선으로 노드를 연결한 선이라고 보면 됨 (link 또는 branch 라고도 함)
- 인접 정점 (Adjacent Vertex) : 간선으로 직접 연결된 정점(또는 노드)
- 참고
  - 정점의 차수 (Degree): 무방향 그래프에서 하나의 정점에 인접한 정점의 수
  - 진입 차수 (In-Degree): 방향 그래프에서 외부에서 오는 간선의 수
  - 진출 차수 (Out-Degree): 방향 그래프에서 외부로 향하는 간선의 수
  - 경로 길이 (Path Length): 경로를 구성하기 위해 사용된 간선의 수
  - 단순 경로 (Simple Path): 처음 정점과 끝 정점을 제외하고 중복된 정점이 없는 경로
  - 사이클 (Cycle): 단순 경로의 시작 정점과 종료 정점이 동일한 경우

## 그래프의 종류

<img width="731" alt="그래프_종류" src="https://user-images.githubusercontent.com/16794320/127731827-67d5dabf-871b-4b8c-a150-07b1749593a8.png">

### 방향 그래프

그래프의 각 간선이 방향이라는 속성을 갖는 그래프

### 가중치 그래프

그래프의 각 간선이 가중치(weight)라는 송석을 갖는 그래프

### 다중 그래프

두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프

### 트리

간선을 통해 두 정점을 잇는 방법이 딱 하나밖에 없는 그래프

### 이분그래프

그래프의 정점들을 겹치지 않는 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 사이에만 간선이 존재하도록 만들 수 있는 그래프

### DAG

사이클 없는 방향 그래프(Directed Acyclic Graph)

기본적으로 방향 그래프, 한 점에서 출발해 자기 자신으로 돌아오는 경로가 없는 경우

## 그래프의 경로

그래프에서 경로란 끝과 끝이 연결된 간선들을 순서대로 나열한 것
<img width="303" alt="그래프_경로" src="https://user-images.githubusercontent.com/16794320/127731829-9ac04786-3ff6-4711-b67f-0e3f7f12233c.png">

주어진 그림에서 1에서 5로 가는 경로는 
(1,2),(2,4),(4,5)와 같이 표현.
간단하게 1-2-4-5로도 표현

## 그래프의 표현 방법

V = 정점의 수

### 인접 리스트

그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현

각 정점마다 하나의 연결 리스트를 갖는 방식으로 구현

### 인접 행렬

인접 리스트가 두 정점의 연결 관계를 확인하기위해 모든 리스트를 뒤져야한다는 단점 보완

|V|X|V| 크기의 행렬(|V|는 정점의 갯수)로 표현한다.

간**선의 수가 $V^2$에 비해서 훨씬 적은 경우 인접리스트를 사용하는 것이 유리하고**

**간선의 수가 $V^2$에 비례하는 경우 인접행렬을 사용하는 것이 유리하다.**

### 암시적 그래프 표현

그래프를 직접 메모리에 표현하지않고 그래프 구조만 사용하는 것이 유리한 경우

- 입력이 그래프의 형태를 띄지않는 문제의 경우(ex. 배열로 주어진 미로)
- 그래프의 크기가 아주 큰데 실제 사용하는 부분은 그래프의 일부분인 경우

# DFS

DFS(Depth-First Search,깊이 우선 탐색)은 그래프의 모든 노드를 탐색하는 가장 단순한 방법입니다.

정점의 자식들을 먼저 탐색하는 방식으로 다음의 순서를 따릅니다.

1. 현재 정점과 인접한 간선들을 하나씩 검사한다.
2. 아직 방문하지 않은 정점으로 향하는 간선이 있다면 그 간선을 따라간다.
3. 더 이상 갈 곳이 없는 막힌 정점에 도달할 때까지 반복한다.
4. 더이상 갈 곳이 없다면 가장 마지막에 지난 간선을 따라 돌아가 더 이상 방문할 정점이 없을 때까지 반복한다.

각 정점이 정수형인 경우를 예시로 설명하겠습니다.


![그래프_표](./img/graph_chart.png)

위와 같이 만들어진 그래프를 DFS로 탐색하는 그림은 다음과 같습니다.

<img src="./img/graph_DFS.png" alt="그래프_DFS" style="zoom:50%;" />


## Java로 그래프를 표현하는 방법

정점의 개수를 n, 간선의 개수를 m,  연결관계에 있는 노드를 (node1, node2)의 순서쌍으로 하면, 다음과 같이 그래프를 표현할 수 있습니다.

```java
Map<Integer, ArrayList<Integer>> graph = new TreeMap<Integer, ArrayList<Integer>>();
int n = 0, m = 0
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
m = sc.nextInt();
//초기화 해줘야지 아래의 반복문에서 nullPointException 발생하지않는다.
for(int i = 0;i<n;i++){
  graph.put(i+1,new ArrayList<>());
}
for(int i = 0;i<m;i++){
  int n1 = 0, v1 = 0;
  node1 = sc.nextInt();
  node2 = sc.nextInt();
  graph.get(n1).add(node2);
  graph.get(node2).add(node1);
}
```



## DFS 알고리즘 구현

스택을 활용해서 구현할 수 있습니다.

```java
//code
public void dfsWithoutRecursion(int start) {
  Stack<Integer> stack = new Stack<Integer>();
  boolean[] isVisited = new boolean[adjVertices.size()];
  stack.push(start);
  while (!stack.isEmpty()) {
    int current = stack.pop();
    isVisited[current] = true;
    visit(current);
    for (int dest : adjVertices.get(current)) {
      if (!isVisited[dest])
        stack.push(dest);
    }
  }
}
```

재귀호출을 통해 메서드 스택을 이용해서 구현하는 방법도 있습니다.

```java
public void dfs(int start) {
  boolean[] isVisited = new boolean[adjVertices.size()];
  dfsRecursive(start, isVisited);
}
void dfsRecursive(int current, boolean[] isVisited) {
  isVisited[current] = true;
  visit(current);
  for (int dest : adjVertices.get(current)) {
    if (!isVisited[dest])
      dfsRecursive(dest, isVisited);
  }
}
```



## 시간 복잡도

일반적으로 DFS의 시간복잡도는 정점의 수를 V, 간선의 수를 E라고 할 때 O(V+E) 입니다.

---



# 알고리즘
## 탐욕법

그리디 알고리즘은 최적화 문제를 해결하는 알고리즘이라고 할 수 있다.

최적화(optimization) 문제란 가능한 해들 중에서 가장 좋은 (최대 또는 최소) 해를 찾는 문제이다.

욕심쟁이 방법, 탐욕적 방법, 탐욕 알고리즘 등으로 불린다.

그리디 알고리즘은 수행 과정에서 탐욕적으로 일단 한 번 선택하면, 이를 절대로 번복하지 않는다.

즉, 선택한 데이터를 버리고 다른 것을 취하지 않는다.

이러한 선택을 근시안적인 선택이라고 말하기도 한다. 이 근시안적인 선택으로 부분적인 최적해를 찾고, 이들을 모아서 최종적으로 문제의 최적해를 얻는 것이다.

이러한 특성 때문에 대부분의 그리디 알고리즘들은 매우 단순하며, 또한 제한적인 문제들만이 그리디 알고리즘으로 해결된다.

대표적으로 알려진 그리디 알고리즘의 예로는 

1. 동전 거스름돈 문제
2. 최소 스패닝 트리 (MST)
3. 최단 경로 찾기
4. 부분 배낭 문제
5. 집합 커버 문제
6. 작업 스케줄링 문제

등이 존재한다.

#### 1. 동전 거스름돈 문제

주어진 동전 단위와 거스름돈을 가지고 최소 동전 수를 찾는 가장 간단하고 효율적인 방법이다.

간단한 문제이므로 간략히 설명하자면, 남아 있는 거스름돈에 대해 가장 높은 액면의 동전을 거스르며 최소 동전 수를 추가하는 방법이다.

큰 화폐를 처리할 수 있을 때, 작은 화폐에 대해서는 전혀 고려하지 않기 때문에 그리디 알고리즘이라고 할 수 있다.

이 동전 거스름돈 문제에서 주의 할 점은, 모든 화폐 단위에서 이 그리디 알고리즘을 적용할 수 없다는 것이다.

만약 200원을 거스르는 문제에서 160원짜리 동전이 존재한다면 어떻게 될까? 

그리디 알고리즘에서는 100원보다 160원이 더 크니까, 160원을 거스르고 그 다음 남은 10원짜리 4개를 거스르면 총 5개가 된다.

하지만 100원 짜리 2개가 최적의 해이므로, 이와 같은 경우가 존재할 수 있기 떄문에 그리디한 방법이 항상 최적의 답을 주지는 못한다.

그래서 실제로 거스름돈에 대한 그리디 알고리즘이 적용되도록 화폐 단위가 발행된다고 한다.

위 같이 160원 동전같은 문제는 DP로 해결이 가능하다.

#### 2. 최소 스패닝 트리 (MST)

최소 스패닝 트리는 주어진 가중치 그래프에서 사이클이 없이 모든 Vertex들을 연결시킨 트리들 중 Edge들의 가중치 합이 최소인 트리를 말한다.

주어진 그래프의 스패닝 트리를 찾는 방법은 사이클이 없도록 모든 Vertex들을 연결시키는 것이다.

그래프의 Vertex의 수가 V개가 있다면, 스패닝 트리에는 반드시 V-1개의 Edge가 존재한다.


<p align="center"><img src="https://user-images.githubusercontent.com/51703260/132085644-87147f86-2622-44dc-aa22-7705e6257df1.png"></p>

위 이미지는 6개의 Vertex를 5개의 Edge로 연결시킨 스패닝 트리가 있고,

스패닝 트리에 Edge를 하나 더 추가시킨다면, 반드시 사이클이 만들어 진다는 것을 보여준다.

[최소 스패닝 트리](#최소-스패닝-트리)를 찾는 그리디 알고리즘으로는 2가지가 존재한다.

1. [크루스칼의 최소 스패닝 트리 알고리즘](#크루스칼의-최소-스패닝-트리-알고리즘)
2. [프림의 최소 스패닝 트리 알고리즘](#프림의-최소-스패닝-트리-알고리즘)

위 최소 스패닝 트리 알고리즘들은 최소 비용으로 선로 또는 파이프 네트워크 (인터넷 광 케이블 선로, 케이블 TV선로, 전화선로, 송유관로, 가스관로, 배수로 등)를 설치하는데 활용된다.

#### 3. 최단 경로 찾기

최단 경로 문제는 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제이다.

[최단 경로 알고리즘](#최단-경로-알고리즘)를 찾는 그리디 알고리즘으로는 2가지가 존재한다.

1. [다익스트라](#다익스트라)
2. [벨만-포드](#벨만-포드)

최단 경로를 찾는 알고리즘은 위 2가지 말고도 [플로이드의 모든 쌍 최단 거리 알고리즘](#플로이드의-모든-쌍-최단-거리-알고리즘)이 존재하지만,

위 알고리즘은 그리디 알고리즘이 아니라, DP 알고리즘 문제이다.

#### 4. 부분 배낭 문제

부분 배낭 문제에 대해 알아보기 위해서는, 먼저 배낭(Knapsack) 문제를 알아야 한다.

배낭 문제란, 
- N개의 물건이 있다.
- 각 물건은 무게와 가치를 가지고 있다.
- 배낭이 한정된 무게의 물건들을 담을 수 있다.

이 때, 최대의 가치를 갖도록 배낭에 넣을 물건들을 정하는 문제이다.

이 배낭 문제는 2가지로 구분 할 수 있다. 

1. 부분 배낭 문제
2. 0/1 배낭 문제

먼저 1. 부분 배낭(Fractional Knapsack)문제는 물건을 부분적으로 담는 것을 허용한다.

이 문제는 그리디 알고리즘으로 해결가능하다.

그 다음 2. 0/1 배낭 문제는 부분 배낭 문제의 원형으로 물건을 부분적으로 담는 것을 허용하지 않고, 물건을 통째로 배낭에 넣어야 한다.

이 문제는 DP 알고리즘, 백트래킹, 분기 한정 기법으로 해결 가능하므로 지금 여기서는 다루지 않도록 하겠다.

부분 배낭 문제에서는 물건을 부분적으로 배낭에 담을 수 있으므로, 

최적해를 위해서 그리디하게 단위 무게 당 가장 값나가는 물건을 배낭에 넣고, 계속해서 그 다음으로 값나가는 물건을 넣는다.

그런데 만일 그 다음으로 값나가는 물건을 통째로 배낭에 넣을 수 없게 되면, 배낭에 넣을 수 있을 만큼만 물건을 부분적으로 배낭에 담는다.

부분 배낭 문제의 대표적인 문제는 아래와 같다.

> **40그램의 용량을 담을 수 있는 주머니가 존재하고, 4개의 금속 분말과 각 물건의 총 무게와 총 가격이 주어진다.**
>
> 이 때, 총 가격이 가장 많이 나갈 수 있도록 주머니에 금속을 담아라.
>
> 물건　　　총 무게　　　총 가격　　 |　　단위 그램당 가격
> 	
> 백금　　　10그램　　　　60만원　　|　　6만원
> 
> 금　　　　15그램　　　　75만원　　|　　5만원
> 
> 은　　　　25그램　　　　10만원　　|　　5천원
> 
> 주석　　　50그램　　　　5만원　　 |　　 1천원

이 문제도 간단하기 때문에 간략하게 설명하자면, 가장 먼저 그리디 알고리즘을 적용시킬 수 있게

세팅이 필요한데, 각 물건의 단위 그램당 가격을 각각 산출하는 것이다.

단위 그램당 가격을 구하면 해당 가격으로 내림차순으로 정렬하여, 단위 그램당 가격이 제일 많이 나가는 백금을 주머니에 담는다.

이 때, 백금보다 단위 그램당 가격이 작은 다른 물건들은 현재 상황에서 전혀 고려하지 않기 때문에 그리디 알고리즘이라고 할 수 있다. 

이제 40-10 = 30 그램을 주머니에 더 담을 수 있고, 주머니의 가치는 6*10 = 60만원이다.

그 다음 가격이 가장 많이 나가는 금을 주머니에 담는다.

이제는 30-15 = 15 그램을 주머니에 더 담을 수 있고, 주머니의 가치는 60 + 5*15 = 135만원이다.

그 다음 마지막으로 배낭에 넣을 수 있는 15그램을 모두 은으로 주머니를 채운다. 이 때, 주머니의 총 가치는 135 + 0.4*15 = 141만원이 된다.

n개의 물건이 존재할 때 부분 배낭 알고리즘의 시간복잡도는,

- O(n) (무게당 가격계산)
- O(n log n) (내림차순 정렬)
- O(n) (물건 개수 반복)
- O(1) (물건넣기)

로 시간 복잡도를 구분할 수 있다. 이 중 내림차순 정렬이 가장 시간이 오래걸리므로 

이 알고리즘의 시간복잡도는 O(n log n)이라고 할 수 있다.

#### 5. 집합 커버 문제

집합 커버 문제는 아래와 같은 문제이다.

> n개의 원소를 가진 집합 U가 있다.
>
> U의 부분집합들을 원소로 하는 집합 F가 주어진다.
>
> **F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?**
>
> **된다면, 집합 F에서 선택하는 집합들의 수의 최솟값은?

집합 커버 문제의 최적해는 어떻게 찾아야 할까?

F에 n개의 집합들이 있다고 가정해보자.

가장 단순한 방법으로는 F에 있는 집합들의 모든 조합을 1개씩 합집합하여 U가 되는지 확인하고, U가 되는 조합의 집합 수가 최소인 것을 찾는 것이다.

그러면 F={S1, S2, S3}일 경우 모든 조합을 구해야 한다.

- 집합이 1개인 경우 3개 = 3C1
- 집합이 2개인 경우 3개 = 3C2
- 집합이 3개인 경우 1개 = 3C3
- 총합은 3+3+1= 7 == 2^3-1 개

즉, O(2^n)의 시간복잡도가 걸리고 이는 exponential time이므로, NP문제가 된다.

n이 커지면 최적해를 찾는 것은 실질적으로 불가능하다는 뜻이고 그럼에도 불구하고 이런 문제가 주어지고 최적해를 찾으라고 한다면

아마 n이 최대 30을 넘진 않을 것이다.

그래서 이를 극복하기 위한 방법으로는 최적해를 찾는 대신에 최적해에 근접한 근사해를 그리디 알고리즘으로 찾는 것이다.

```
// 수도코드

Set U = U; // 커버를 해야하는 전체 집합 U
Set F = {S1, S2,,,Sn}; // U의 부분집합들을 원소로 하는 집합 F

setCover(U, F){
	Set C = (); // 빈 집합
	
	while(!U.isEmpty()){
		Set temp;
		for(Set s : F){
			// 남은 것 중가장 많이 커버하기만 하면 일단 선택하기 때문에 그리디 알고리즘이다.
			if(s가 U의 남은 원소를 가장 많이 커버하면){ 
				temp = s;
			}
		}
		U.remove(temp); // U에서 제거 
		C.add(temp); // C에 추가
	}
	
	return C;
}
```

실제로 위 처럼 짜면 remove에서 런타임 에러가 발생하겠지만 대략적인 논리의 수도코드를 적어보았다.

위 집합 커버 문제의 근사해 알고리즘의 시간복잡도는 전체 집합 U의 사이즈가 n이라고 할 때

루프가 n번 반복되고, 각 루프당 F의 원소 Si의 수가 최대 n이라면 F와 U의 비교는 총 n^2이 걸리므로

시간복잡도는 O(n^3)이라고 할 수 있다.

#### 6. 작업 스케줄링 문제

보통 작업 스케줄링 문제는 2가지 유형이 있다.

1. 모든 작업을 최소 기계로 완료하는 문제
2. 기계 1대로 최대한 많은 작업하는 문제

일단 **1. 모든 작업을 최소 기계로 완료하는 문제**부터 설명하자면,

이 문제는 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제라고 할 수 있다.

작업 스케줄링 문제에는 여러가지 문제 요소들이 주어지는데,

1. 작업 수 // 그냥 입력의 크기라 중요한 요소는 아님
2. 각 작업의 시작과 종료시간

이 문제를 해결할 수 있는 작업 스케줄링 알고리즘은 4가지로 구분할 수 있다.

1. 빠른 시작시간 작업 우선 배정
2. 빠른 종료시간 작업 우선 배정
3. 짧은 작업 우선 배정
4. 긴 작업 우선 배정

위 4가지 알고리즘 중 1. 빠른 시작시간 작업 우선 배정 알고리즘을 제외하고 나머지 3가지 알고리즘은 항상 최적해를 찾아주는 것은 아니다.

1. 빠른 시작시간 작업 우선 배정은 작업을 시작할 때, 기계를 사용 가능하면 빈기계에서 작업을 수행하고 만약 빈기계가 없다면 기계를 새로 추가함으로 써 문제를 해결할 수 있다.

```
// 수도코드

job[N]; // N개의 작업 j1, j2, j...
pq = pq(job); // 이른 시작시간을 기준으로 한 minHeap
result = job_Scheduling(pq);

job_Scheduling(pq){
	cnt = 0;
	while(!pq.isEmpty()){
		j = pq.dequeue();
		if(j를 수행할 기계가 존재){
			기계에 작업 배정;	
		}
		else{
			cnt;
		}
			
	}
	return cnt;
}

```
위 수도코드에서 작업을 수행할 기계가 존재하는지, 그리고 존재하면 기계에 작업배정하여 스케줄링하는 부분은 간단히 표현하였다.

전체 작업 시간의 사이즈의 boolean배열의 리스트를 선언하고, 기계가 추가되면 리스트에 배열을 추가하는 식으로 구현하면 된다.

위 알고리즘의 시간 복잡도는 먼저 n개의 작업을 정렬하는데 O(n log n)이 걸린다.

그리고 n번의 while 루프에서 작업 수행이 가능 한 기계를 탐색하는데 O(nm)이 걸린다. // m은 사용된 기계의 수

m이 log n보다 큰지 작은지 구분이 안되기 때문에, O(n log n) 와 O(nm) 중 어느것이 해당 알고리즘의 시간 복잡도인지 알 수 없기 때문에,

해당 알고리즘의 시간복잡도는 O(n log n) + O(nm)이다.


그 다음 **2. 기계 1대로 최대한 많은 작업하는 문제도** 마찬가지로 작업의 수가 주어지고, 각 작업의 시작시간과 종료시간이 주어진다.

여기서 1개의 기계로 최대한 많은 작업을 스케줄링하는 문제인데, 이 문제는 시작시간을 기준으로 정렬해도 되고, 종료시간을 기준으로 정렬해도 된다.

만약 종료시간을 우선적으로 기준으로 정렬을 했을 때는 종료시간이 같다면 일찍 시작하는 작업순으로 정렬하면 되고,

만약 시작시간을 우선적으로 기준으로 정렬을 했을 때는 시작시간이 같다면 일찍 종료하는 작업순으로 정렬하면 된다.

이른 종료시간을 우선적으로 정렬하였을 때의 수도코드는 이래와 같다.
```
// 수도코드

job[N]; // N개의 작업 j1, j2, j...
pq = pq(job); // 이른 종료시간을 기준으로 한 minHeap
result = job_Scheduling(pq);

job_Scheduling(pq){
	start = 0;
	cnt = 0;
	
	while(!pq.isEmpty){
		j = pq.dequeue();
		if(start <= j.start){
			start = j.end;
			cnt++
		}
	}
	
	return cnt;
}
```

모든 작업을 수행하기 위해 최소 기계수를 카운트하는 1번 문제와 그리디하게 접근하는 것이 비슷해 보이지만,

이 문제는 1대의 기계로 최대의 작업수를 카운트한다는 것에서 다르다고 할 수 있다.

---

# 정렬
## 셸 정렬

셸 정렬은 우선적으로 버블 정렬과 삽입 정렬에 대한 이야기가 필요하다.

버블 정렬이나 삽입 정렬이 수행되는 과정은 이웃하는 원소끼리의 자리 이동으로 원소들이 정렬된다.

버블 정렬이 오름차순으로 정렬하는 과정에서 작은 숫자가 배열의 앞부분으로 매우 느리게 이동한다.

그리고 삽입 정렬의 경우는 만일 배열의 마지막 원소가 가장 작은 숫자일 경우 그 숫자가 배열의 맨 앞으로 이동해야 하므로, 모든 다른 숫자들이 1칸씩 뒤로 이동해야한다.

셸 정렬은 이러한 단점을 보완하기 위해서 삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자들을 앞부분으로 빠르게 이동시키고,

동시에 앞부분의 큰 숫자들은 뒷부분으로 이동시키고, 그리고 가장 마지막에는 삽입 정렬을 수행하는 알고리즘이다.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/132044503-092612ca-9df9-4f4f-a6a5-4601f5b0d136.gif"></p>

#### 쉘 정렬 아이디어

만약 아래와 같이 값이 저장된 배열이 존재한다고 하자.

> **30 60 90 10 40 80 40 20 10 60 50 30 40 90 80**

먼저 간격 (gap)이 5가 되는 숫자끼리 그룹을 만든다.

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/132047715-211c4c09-f14b-499c-a7da-44c29b24af48.png"></p>

각 그룹 별로 삽입 정렬을 수행한 결과를 1줄에 나열해 보면 다음과 같다.

> **30 30 20 10 40   /   50 40 40 10 60   /   80 60 90 90 80**

간격이 5인 그룹 별로 정렬한 결과

- 80과 90같은 큰 숫자가 뒷부분으로 이동하였고,
- 20과 30같은 작은 숫자가 앞부분으로 이동하였다.

그 다음엔 간격을 5보다 작게 하여, 예를 들어, 3으로 하여, 3개의 그룹으로 나누어 각 그룹별로 삽입 정렬을 수행한다.

- 이때에는 각 그룹에 5개의 숫자가 있다.

최종적으로 마지막에는 반드시 간격을 1로 놓고 수행해야 한다.

- 그 이유는, 다른 그룹에 속해 서로 비교되지 않은 숫자가 있을 수 있기 때문이다.
- 즉, 모든 원소를 1개의 그룹으로 여기는 것이고, 이는 삽입 정렬 그 자체이다.
- 삽입 정렬은 대강 정렬이 되어있는 상태에서 좋은 성능을 발휘한다.

```
// 수도코드
A[N]; // 크기가 N인 정렬되지 않은 배열
shell_Sort(A);

shell_Sort(A){
	gap = [ g0 > g1 > ... > gk = 1 ]; // 큰 gap부터 차례로 저장된 gap배열, 마지막 gap은 반드시 1
	for(g : gap){
		for(i = 0; i < g; i++) { // gap 만큼 반복한다
			insertion_Sort(i, gap); // 삽입 정렬
		}
	}
}

insertion_Sort(i, gap){
	for(j = i + gap; j < N; j += gap){ // gap만큼 점프하며 삽입 정렬 수행
		for(x = i; x < j; x += gap){
			if(A[x] > A[j]){
				swap(A, x, j);
			}
		}
	}
}

swap(A, i, j){
	temp = A[i];
	A[i] = A[j];
	A[j] = temp;
}

```

<p align="center"><img src="https://user-images.githubusercontent.com/51703260/132052008-19038dcc-629b-4d3d-b023-d4802fd4f4f0.png"></p>

만약 gap의 5라서 5개의 그룹이 구분되면, 각 그룹별로 삽입 정렬을 수행한다.

이 과정으로 인해 앞에 있는 큰 수가 빠르게 뒤로 가고, 뒤에 있는 작은 수가 빠르게 앞으로 올 수 있게 된다.

gap을 차차 줄여가며, 최종적으로 gap을 1을 둔 삽입 정렬을 시행한다.

삽입 정렬은 이미 어느정도 정렬이 된 상태일수록 효율이 O(N)에 가까워 진다.

#### 시간복잡도

쉘 정렬의 최악 경우의 시간복잡도는 O(n2)이며, 쉘 정렬의 수행 속도는 간격 선정에 따라 좌우된다.

쉘 정렬은 1959년에 발표될 정도로 역사가 오래된 정렬 알고리즘인 만큼, 이 알고리즘에 대한 많은 실험들이 진행되어왔다.

그 중 가장 유명한 gap 설정 방법인 히바드(Hibbard) 간격을 사용하면 O(n^(1.5)) 라고 한다.

히바드 간격은 시작 간격을 2^k - 1로 두고 k를 1씩 줄여서 2^k -1, ... , 15, 7, 3, 1로 간격을 설정하는 방법이다.

이 후 많은 실험을 통한 현재까지의 쉘 정렬의 최적의 시간복잡도는 O(n^(1.25))으로 알려지고 있다.

아직까지는 가장 좋은 간격이 무엇인지 밝혀지지 않기 때문에, 쉘 정렬의 시간 복잡도는 아직 풀리지 않은 문제 이다.

지금까지 알려진 가장 좋은 성능을 보인 간격은 Marcin Ciura이 밝혀낸 1750, 701, 301, 132, 57, 23, 10, 4, 1 이라고 한다.

마지막으로 정리하자면, 쉘 정렬은 입력 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보인다.

쉘 정렬은 임베디드(Embedded) 시스템에서 주로 사용되는데, 쉘 정렬의 특징인 간격에 따른 그룹 별 정렬 방식이 H/W로 정렬 알고리즘을 구현하는데 매우 적합하기 때문이라고 한다.
